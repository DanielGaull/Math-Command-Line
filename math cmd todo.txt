Advanced Math:
*Redo derivative & integral & solve w/ better precision

Operation Definitions (?):
*More difficult, but allow for defining custom operations

Package Files instead of function files:
*custom.pkg is the default one that creating things goes to
*3 types of things in package files:
  -Functions (line starts with .f)
  -Data Types (line starts with .d)
  -Operations (line starts with .o)
*List of operation characters: +, -, *, /, ^, %
*Data types:
  -These work by containing FIELDS which is the actual data stored, and defining a display for that data using valid characters, and the name
     > Need the comma-separated field values, and the format of the data (the field name in the format has {} around it)
     > Valid characters: cannot be an operation character, or {}, or a space, or start with a letter
  -Can provide restrictions on fields, where you put parenthesis in the field and comma separated restrictions
     > Allowed restrictions: <, >, >=, <=, int (must be integer)
  -Can represent a list of data in the format as a list notation like {} with a $ at the start
  -Specify the data type (# for number, $ for list) when declaring it at the start
  -i.e. for a vector we'd use a list, so we'd have something like:
     > .d vector $vectvals <{$vectvals}> - The {$vectvals} means that we'd not put a list in here, but type out each number (or can also put a list in here)
  -Another example for a time format:
     > .d timeHMS #hrs(int),#mins(int,<60),#secs(<60) {hrs}:{mins}:{secs} 
  -Detecting in parser
  -AST type
  -Come up with way to handle providing wrong data types to functions again
     > Could now make it so they require a certain data type, and giving the wrong one won't work
  -Remove the hard-coded vector type and create a vector package that contains the vector type and all vector functions
  -Create time type and functions
*Operations:
  -Operations must be binary. If you want a non-binary operation, use a function
  -Define the operation symbol, and the two operands (name and type), the result (the result is an expression), and unlimited conditions after the result
     > Possible conditions: expressions with =, >, >=, <, <=
  -Can access the data stored in the operands with . notation
     > ex for a timeHMS, can do time.hrs
  -Example for vector subtraction:
     > .o - v1(vector),v2(vector) <repeat([i:get(v1.vectvals,i)-get(v2.vectvals,i)],len(v1.vectvals))> len(v1.vectvals)=len(v2.vectvals)
  -Example for timeMS addition:
     > .o + t1(timeMS),t2(timeMS) floor((t1.mins*60+t1.secs+t2.mins*60+t2.secs)/60):(t1.mins*60+t1.secs+t2.mins*60+t2.secs)%60
*New repeat function:
  -Takes in delegate and # of iterations
  -Returns a list with the evaluation of the delegate at each iteration
  -Starts at 0 and goes up to n-1

Packages:
*Custom functions break?
  -stirling2 runs if we run it as a custom function normally, but when loaded from a package it doesn't work?
*Some handling for ambiguous names
  -So if we have package X with a function funct and a package Y with a function funct, then we call X's with X.funct and Y's with Y.funct
*Functions to add to base package:
  -

Misc:
*Allow delegates to be directly used as functions
  -ex.) [x,y:x*y](7,4.2)
  -Not very necessary since you can simply plug the values in, but may be helpful for some
*Video tutorial
*List split function
*Some method of native code execution. Ability to create functions that run on native (C?) code

Bugs:
*Test the custom function with annuity (need to create it). Program stalls for some reason

Locking Functions/Vars:
*Way to prevent them from being deleted
*Way to prevent vars from being changed (set constant means they cannot be changed)

Matrices:
*Matrices
*Can create them from vector list (vectors will be the rows/cols, have matrr and matrc functions)
*Adding/subtracting
*Multiplying by scalar
*Multiplying matrices together
*Idenity matrix func (takes in the size)
*Inverse function
*Transpose function

Refactoring:
*AdvancedMath class that has functions for differentiating/integrating/solving/etc., and also can handle lists and vectors
*Class that produces an output given Ast, so that Program doesn't have to do that anymore

Create Installer
*Write program to generate expressions to test and compare to C#
*Doesn't properly create env vars
*Needs to install Dotnet

Online Page
  -Note that <> doesn't work with command line, better to run m and use inf mode for complex applications